"""Unit Tests for main.py. Generated by an AI assistant; review before use."""

import io
import sys
import os
import json
from jsonschema import validate
import subprocess
import requests
import responses
import pytest
from unittest.mock import patch

from rekor_monitor_nyu_sscs import main

checkpoint_schema = {
    "type": "object",
    "properties": {
        "inactiveShards": {"type": "array"},
        "rootHash": {"type": "string"},
        "signedTreeHead": {"type": "string"},
        "treeID": {"type": "string"},
        "treeSize": {"type": "integer"},
    },
    "required": ["inactiveShards", "rootHash", "signedTreeHead", "treeID", "treeSize"],
}


def test_checkpoint():
    env = os.environ.copy()
    env["PYTHONPATH"] = "src"

    result = subprocess.run(
        ["python", "-m", "rekor_monitor_nyu_sscs.main", "-c"],  # Run as module
        capture_output=True,
        text=True,
        env=env,
        cwd=os.path.dirname(os.path.dirname(__file__)),  # Run from project root
    )
    output = result.stdout
    data = json.loads(output)

    validate(instance=data, schema=checkpoint_schema)


# Mock response body.
log_index = 126574567
mock_uuid = "24296fb24b8ad77a8c51f8f89aa6012e7f54fcf64d0f866e3fa11e8b94845dd0f2e1d2e4"
mock_json = {
    mock_uuid: {
        "body": "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiJhYmMxMjMifX0sInNpZ25hdHVyZSI6eyJjb250ZW50IjoiTUVVQ0lRQ...",
        "integratedTime": 1234567890,
        "logIndex": log_index,
        "logID": "c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d",
        "verification": {
            "inclusionProof": {
                "hashes": [
                    "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
                    "5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03",
                ],
                "logIndex": log_index,
                "rootHash": "abc123def456789",
                "treeSize": 150000000,
            },
            "signedEntryTimestamp": "MEUCIQDsomething...",
        },
    }
}

mock_checkpoint = {
    "inactiveShards": [],
    "rootHash": "abc123",
    "signedTreeHead": "signed_data",
    "treeID": "tree_123",
    "treeSize": 1000000,
}


@responses.activate
def test_get_latest_checkpoint():
    responses.add(
        responses.GET,
        "https://rekor.sigstore.dev/api/v1/log",
        json=mock_checkpoint,
        status=200,
    )

    response = main.get_latest_checkpoint()
    assert isinstance(response, dict)
    validate(instance=response, schema=checkpoint_schema)


class TestGetLogEntry:
    @responses.activate
    def test_get_log_entry_success(self):
        """Test successful retrieval of a log entry. Mock response is created by LLM."""

        responses.add(
            responses.GET,
            f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
            json=mock_json,
            status=200,
        )

        uuid, log_entry = main.get_log_entry(log_index)

        assert uuid == mock_uuid
        assert isinstance(log_entry, dict)
        assert uuid in log_entry
        assert "body" in log_entry[uuid]
        assert "logIndex" in log_entry[uuid]
        assert "verification" in log_entry[uuid]
        assert log_entry[uuid]["logIndex"] == log_index
        assert log_entry[uuid]["body"].startswith("eyJ")

    @responses.activate
    def test_get_log_entry_invalid_content_400(self):
        log_index = -1

        responses.add(
            responses.GET,
            f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
            json={"code": 400, "message": "invalid log index"},
            status=400,
        )

        with pytest.raises(
            ValueError, match="content supplied to the server was invalid"
        ):
            main.get_log_entry(log_index)

    @responses.activate
    def test_get_log_entry_invalid_content_404(self):
        log_index = 99999999999999999

        responses.add(
            responses.GET,
            f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
            json={"code": 404, "message": "entry not found"},
            status=404,
        )

        with pytest.raises(requests.exceptions.HTTPError):
            main.get_log_entry(log_index)


@responses.activate
def test_get_log_entry_body_b64_success():
    """Test successful extraction of body field"""
    log_index = 123
    mock_body = "eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIn0="
    mock_json = {"test-uuid": {"body": mock_body, "logIndex": log_index}}

    responses.add(
        responses.GET,
        f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
        json=mock_json,
        status=200,
    )

    body = main.get_log_entry_body_b64(log_index)

    assert body == mock_body
    assert isinstance(body, str)


class TestInclusion:
    """Tests for the inclusion function"""

    @responses.activate
    @patch("rekor_monitor_nyu_sscs.main.verify_inclusion")
    @patch("rekor_monitor_nyu_sscs.main.compute_leaf_hash")
    @patch("rekor_monitor_nyu_sscs.main.verify_artifact_signature")
    @patch("rekor_monitor_nyu_sscs.main.parse_log_entry")
    def test_inclusion_success(
        self,
        mock_parse_log_entry,
        mock_verify_artifact_signature,
        mock_compute_leaf_hash,
        mock_verify_inclusion,
    ):
        """Test successful inclusion verification"""
        log_index = 123456
        artifact_filepath = "/path/to/artifact.txt"

        # Mock the API responses
        body_b64 = "eyJhcGlWZXJzaW9uIjoiMC4wLjEifQ=="
        mock_json = {
            "test-uuid": {
                "body": body_b64,
                "logIndex": log_index,
                "verification": {
                    "inclusionProof": {
                        "hashes": ["hash1", "hash2"],
                        "logIndex": log_index,
                        "rootHash": "root123",
                        "treeSize": 1000,
                    }
                },
            }
        }

        # Mock both API calls (get_log_entry_body_b64 and get_verification_proof)
        responses.add(
            responses.GET,
            f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
            json=mock_json,
            status=200,
        )
        responses.add(
            responses.GET,
            f"https://rekor.sigstore.dev/api/v1/log/entries?logIndex={log_index}",
            json=mock_json,
            status=200,
        )

        # Mock parse_log_entry to return signature and public key bytes
        mock_sig_bytes = b"signature_bytes"
        mock_pubkey_bytes = b"pubkey_bytes"
        mock_parse_log_entry.return_value = (mock_sig_bytes, mock_pubkey_bytes)

        # Mock verify_artifact_signature to return True
        mock_verify_artifact_signature.return_value = True

        # Mock compute_leaf_hash
        mock_leaf_hash = "computed_leaf_hash"
        mock_compute_leaf_hash.return_value = mock_leaf_hash

        # Mock verify_inclusion to not raise any exceptions
        mock_verify_inclusion.return_value = None

        main.inclusion(log_index, artifact_filepath, debug=False)

        # Verify all the mocked functions were called correctly
        mock_parse_log_entry.assert_called_once_with(body_b64, False)
        mock_verify_artifact_signature.assert_called_once_with(
            mock_sig_bytes, mock_pubkey_bytes, artifact_filepath
        )
        mock_compute_leaf_hash.assert_called_once_with(body_b64)
        mock_verify_inclusion.assert_called_once_with(
            main.DEFAULT_HASHER,
            mock_json["test-uuid"]["verification"]["inclusionProof"],
            mock_leaf_hash,
            False,
        )


@patch("rekor_monitor_nyu_sscs.main.extract_public_key")
@patch("rekor_monitor_nyu_sscs.main.logger")
@patch("rekor_monitor_nyu_sscs.main.base64.b64decode")
@patch("rekor_monitor_nyu_sscs.main.json.loads")
def test_parse_log_entry_success(
    mock_json_loads, mock_b64decode, mock_logger, mock_extract_public_key
):
    body_b64 = "dummy_b64"
    fake_body = {
        "spec": {
            "signature": {
                "content": "sig_b64",
                "publicKey": {"content": "pubkey_b64"},
            }
        }
    }

    mock_b64decode.side_effect = [
        b'{"spec": {"signature": {"content": "sig_b64", "publicKey": {"content": "pubkey_b64"}}}}',
        b"sig_bytes",
        b"cert_bytes",
    ]
    mock_json_loads.return_value = fake_body
    mock_extract_public_key.return_value = b"pubkey_bytes"

    sig_bytes, pubkey_bytes = main.parse_log_entry(body_b64, debug=True)

    assert sig_bytes == b"sig_bytes"
    assert pubkey_bytes == b"pubkey_bytes"

    mock_logger.debug.assert_called()  # ensures debug logs were hit


class TestGetProof:
    @responses.activate
    def test_get_proof_success(self):
        first, last = 1, 10
        url = f"https://rekor.sigstore.dev/api/v1/log/proof?firstSize={first}&lastSize={last}"
        mock_json = {"proof": ["abc123"]}
        responses.add(responses.GET, url, json=mock_json, status=200)

        result = main.get_proof(first, last)

        assert result == mock_json
        assert len(responses.calls) == 1
        assert responses.calls[0].request.url == url

    @responses.activate
    def test_get_proof_invalid_content_400(self):
        first, last = 5, 10
        url = f"https://rekor.sigstore.dev/api/v1/log/proof?firstSize={first}&lastSize={last}"
        responses.add(
            responses.GET,
            url,
            json={"code": 400, "message": "invalid sizes"},
            status=400,
        )

        with pytest.raises(ValueError, match="invalid"):
            main.get_proof(first, last)


class TestConsistency:
    @patch("rekor_monitor_nyu_sscs.main.verify_consistency")
    @patch("rekor_monitor_nyu_sscs.main.get_proof")
    @patch("rekor_monitor_nyu_sscs.main.get_latest_checkpoint")
    @patch("rekor_monitor_nyu_sscs.main.logger")
    def test_consistency_success(
        self,
        mock_logger,
        mock_get_latest_checkpoint,
        mock_get_proof,
        mock_verify_consistency,
    ):
        prev_checkpoint = {"treeSize": 10, "rootHash": "abc123"}
        latest_checkpoint = {"treeSize": 15, "rootHash": "def456"}

        mock_get_latest_checkpoint.return_value = latest_checkpoint
        mock_get_proof.return_value = {"hashes": ["hash1", "hash2"]}

        main.consistency(prev_checkpoint, debug=True)

        mock_get_latest_checkpoint.assert_called_once()
        mock_get_proof.assert_called_once_with(10, 15, True)
        mock_verify_consistency.assert_called_once_with(
            main.DEFAULT_HASHER,
            (10, 15),
            ["hash1", "hash2"],
            ("abc123", "def456"),
        )
        mock_logger.debug.assert_called()

    def test_consistency_missing_tree_size(self):
        prev_checkpoint = {"treeSize": None, "rootHash": "abc123"}
        with pytest.raises(SystemExit):
            main.consistency(prev_checkpoint)

    def test_consistency_missing_root_hash(self):
        prev_checkpoint = {"treeSize": 10, "rootHash": None}
        with pytest.raises(SystemExit):
            main.consistency(prev_checkpoint)


@patch("rekor_monitor_nyu_sscs.main.get_latest_checkpoint")
def test_main_checkpoint(mock_get_latest_checkpoint):
    mock_get_latest_checkpoint.return_value = {"treeSize": 100, "rootHash": "abc123"}

    test_args = ["prog", "--checkpoint"]
    with patch.object(sys, "argv", test_args):
        # capture printed output
        with patch("sys.stdout", new_callable=io.StringIO) as mock_stdout:
            main.main()
            output = mock_stdout.getvalue()

    # assert it printed JSON checkpoint
    printed_json = json.loads(output)
    assert printed_json == {"treeSize": 100, "rootHash": "abc123"}

    # assert get_latest_checkpoint was called
    mock_get_latest_checkpoint.assert_called_once()
