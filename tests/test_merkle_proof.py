"""Unit tests for merkle_proof.py. Generated by an AI assistant; review before use."""

import base64
import pytest
from unittest.mock import patch, MagicMock
from rekor_monitor_nyu_sscs import merkle_proof


class TestBytearrayFromHashes:
    def test_bytearray_from_hashes_basic(self):
        hashes = [
            "00ff",
            "deadbeef",
            "cafebabe",
        ]
        expected = [
            bytes.fromhex("00ff"),
            bytes.fromhex("deadbeef"),
            bytes.fromhex("cafebabe"),
        ]
        result = merkle_proof._bytearray_from_hashes(hashes)

        assert result == expected
        assert all(isinstance(x, bytes) for x in result)
        assert len(result) == 3

    def test__bytearray_from_hashes_empty_list(self):
        assert merkle_proof._bytearray_from_hashes([]) == []

    def test__bytearray_from_hashes_invalid_hex(self):
        with pytest.raises(ValueError):
            merkle_proof._bytearray_from_hashes(["hiyongjae"])


class TestValidateTreeSizesAndProof:
    def test_validate_raises_if_size2_less_than_size1(self):
        with pytest.raises(ValueError, match="tree_sizes"):
            merkle_proof._validate_treesizes_and_proof((10, 5), [b"a"])

    def test_validate_equal_sizes_with_empty_proof_allowed(self):
        # Should not raise
        merkle_proof._validate_treesizes_and_proof((10, 10), [])

    def test_validate_equal_sizes_with_nonempty_proof_raises(self):
        with pytest.raises(ValueError, match="bytearray_proof"):
            merkle_proof._validate_treesizes_and_proof((10, 10), [b"x"])

    def test_validate_zero_size_with_empty_proof_allowed(self):
        # Should not raise
        merkle_proof._validate_treesizes_and_proof((0, 5), [])

    def test_validate_zero_size_with_nonempty_proof_raises(self):
        with pytest.raises(ValueError, match="expected empty bytearray_proof"):
            merkle_proof._validate_treesizes_and_proof((0, 5), [b"x"])

    def test_validate_nonzero_with_empty_proof_raises(self):
        with pytest.raises(ValueError, match="empty bytearray_proof"):
            merkle_proof._validate_treesizes_and_proof((5, 10), [])


class TestComputeLeafHash:
    def test_compute_leaf_hash_correctness(self):
        data = b"hello world"
        body_b64 = base64.b64encode(data).decode("utf-8")
        expected_hex = (
            "4eccf34608d31bac5c7becf6006df59005d828181056d092084e341e6bb005bd"
        )

        result = merkle_proof.compute_leaf_hash(body_b64)
        assert result == expected_hex

    def test_compute_leaf_hash_empty_input(self):
        body_b64 = base64.b64encode(b"").decode("utf-8")
        expected = "6e340b9cffb37a989ca544e6bb780a2c78901d3fb33738768511a30617afa01d"

        result = merkle_proof.compute_leaf_hash(body_b64)
        assert result == expected

    def test_compute_leaf_hash_invalid_base64(self):
        with pytest.raises(Exception):  # base64.b64decode raises binascii.Error
            merkle_proof.compute_leaf_hash("$$invalid!!")


class TestComputeLayoutForConsistencyVerification:
    def test_power_of_two_case(self):
        # size1 = 4 is a power of two
        size1, size2 = 4, 8
        root1_bytes = b"abcd"

        # Compute expected counts so we provide a valid proof length
        inner, border = merkle_proof.decomp_incl_proof(size1 - 1, size2)
        shift = (size1 & -size1).bit_length() - 1
        inner -= shift
        start = 0  # because size1 == 1 << shift for power-of-two
        want = start + inner + border  # must be 1 for (4,8)

        proof_nodes = [b"x"] * want  # exactly the required length

        seed, got_inner, mask, remaining = (
            merkle_proof._compute_layout_for_consistency_verification(
                size1, size2, root1_bytes, proof_nodes
            )
        )

        # Power-of-two branch uses root1_bytes as seed and start=0
        assert seed == root1_bytes
        assert got_inner == inner
        assert remaining == proof_nodes  # start=0, nothing dropped
        # Optional sanity checks (non-brittle)
        assert isinstance(mask, int)
        assert mask == (size1 - 1) >> shift  # (= 0 for size1=4)

    def test_non_power_of_two_case(self):
        # size1 = 6 is not a power of two
        size1, size2 = 6, 8
        root1_bytes = b"root"

        # Compute required proof length
        inner, border = merkle_proof.decomp_incl_proof(size1 - 1, size2)
        shift = (size1 & -size1).bit_length() - 1
        inner -= shift
        start = 1  # non-power-of-two branch
        want = start + inner + border  # for (6,8) this is 3

        proof_nodes = [b"a", b"b", b"c"][:want]

        seed, got_inner, mask, remaining = (
            merkle_proof._compute_layout_for_consistency_verification(
                size1, size2, root1_bytes, proof_nodes
            )
        )

        # Non-power-of-two: seed comes from proof_nodes[0], remaining starts after it
        assert seed == proof_nodes[0]
        assert remaining == proof_nodes[start:]
        assert got_inner == inner
        assert mask == (size1 - 1) >> shift  # (= 2 for size1=6)

    def test_invalid_proof_length_raises(self):
        size1, size2 = 4, 8
        root1_bytes = b"abcd"

        # Deliberately wrong length: for (4,8) want == 1, we give 0
        proof_nodes = []

        with pytest.raises(ValueError, match="wrong bytearray_proof size"):
            merkle_proof._compute_layout_for_consistency_verification(
                size1, size2, root1_bytes, proof_nodes
            )


class TestChainFunctions:
    def setup_method(self):
        self.hasher = merkle_proof.DEFAULT_HASHER

    def test_chain_inner(self):
        seed = b"L"
        proof = [b"A", b"B"]
        index = 2  # binary 10

        # Manual computation for expected
        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + seed + proof[0])
        first = h.digest()
        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + proof[1] + first)
        expected = h.digest()

        result = merkle_proof.chain_inner(self.hasher, seed, proof, index)
        assert result == expected

    def test_chain_inner_right(self):
        seed = b"L"
        proof = [b"A", b"B"]
        index = 3  # binary 11 â†’ both right positions

        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + proof[0] + seed)
        first = h.digest()
        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + proof[1] + first)
        expected = h.digest()

        result = merkle_proof.chain_inner_right(self.hasher, seed, proof, index)
        assert result == expected

    def test_chain_border_right(self):
        seed = b"S"
        proof = [b"A", b"B"]

        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + proof[0] + seed)
        first = h.digest()
        h = self.hasher.new()
        h.update(bytes([merkle_proof.RFC6962_NODE_HASH_PREFIX]) + proof[1] + first)
        expected = h.digest()

        result = merkle_proof.chain_border_right(self.hasher, seed, proof)
        assert result == expected


class TestVerifyMatchA:
    def test_verify_match_success(self):
        data = b"samehash"
        assert merkle_proof.verify_match(data, data) is True

    def test_verify_match_raises_root_mismatch_error(self):
        expected = b"abcd"
        calculated = b"wxyz"

        with pytest.raises(merkle_proof.RootMismatchError) as excinfo:
            merkle_proof.verify_match(calculated, expected)

        # Check that error message includes both roots in hex form
        msg = str(excinfo.value)
        assert "calculated root" in msg
        assert "does not match expected root" in msg
        assert "7778797a" in msg  # hex for 'wxyz'
        assert "61626364" in msg  # hex for 'abcd'


class TestRootFromInclusionProof:
    def setup_method(self):
        self.mock_hasher = MagicMock()
        self.mock_hasher.size.return_value = 32
        self.mock_hasher.hash_children.side_effect = (
            lambda l, r: b"(" + l + b"|" + r + b")"
        )

    def test_valid_root_from_inclusion_proof(self):
        index, size = 1, 4
        leaf_hash = b"x" * 32
        proof = [b"A", b"B"]

        merkle_proof.chain_inner = MagicMock(return_value=b"inner")
        merkle_proof.chain_border_right = MagicMock(return_value=b"final")

        result = merkle_proof.root_from_inclusion_proof(
            self.mock_hasher, index, size, leaf_hash, proof
        )

        # inner = 2 for (index=1, size=4)
        merkle_proof.chain_inner.assert_called_once_with(
            self.mock_hasher, leaf_hash, proof[:2], index
        )
        merkle_proof.chain_border_right.assert_called_once_with(
            self.mock_hasher, b"inner", proof[2:]
        )
        assert result == b"final"


class TestVerifyInclusion:
    @patch("rekor_monitor_nyu_sscs.merkle_proof.logger")
    @patch("rekor_monitor_nyu_sscs.merkle_proof.verify_match")
    @patch("rekor_monitor_nyu_sscs.merkle_proof.root_from_inclusion_proof")
    @patch("rekor_monitor_nyu_sscs.merkle_proof._bytearray_from_hashes")
    def test_verify_inclusion_success(
        self, mock_from_hashes, mock_root_from_inclusion, mock_verify_match, mock_logger
    ):
        hasher = MagicMock()
        inclusion_proof = {
            "hashes": ["aa", "bb"],
            "rootHash": "abcd1234",
            "logIndex": 1,
            "treeSize": 4,
        }
        leaf_hash = "deadbeef"

        mock_from_hashes.return_value = [b"a", b"b"]
        mock_root_from_inclusion.return_value = b"computed_root"
        mock_verify_match.return_value = True

        merkle_proof.verify_inclusion(hasher, inclusion_proof, leaf_hash, debug=True)

        # Assert
        mock_from_hashes.assert_called_once_with(inclusion_proof["hashes"])
        mock_root_from_inclusion.assert_called_once_with(
            hasher,
            inclusion_proof["logIndex"],
            inclusion_proof["treeSize"],
            bytes.fromhex(leaf_hash),
            [b"a", b"b"],
        )
        mock_verify_match.assert_called_once_with(
            b"computed_root", bytes.fromhex("abcd1234")
        )
        mock_logger.debug.assert_any_call(
            "Calculated root hash %s", b"computed_root".hex()
        )
        mock_logger.debug.assert_any_call(
            "Given root hash %s", bytes.fromhex("abcd1234").hex()
        )


class TestVerifyConsistency:
    @patch("rekor_monitor_nyu_sscs.merkle_proof.verify_match", return_value=True)
    @patch("rekor_monitor_nyu_sscs.merkle_proof.chain_inner", return_value=b"h2")
    @patch(
        "rekor_monitor_nyu_sscs.merkle_proof.chain_inner_right",
        return_value=b"h1_inner",
    )
    @patch(
        "rekor_monitor_nyu_sscs.merkle_proof.chain_border_right",
        side_effect=[b"final1", b"final2"],
    )
    @patch(
        "rekor_monitor_nyu_sscs.merkle_proof._compute_layout_for_consistency_verification"
    )
    @patch("rekor_monitor_nyu_sscs.merkle_proof._validate_treesizes_and_proof")
    @patch("rekor_monitor_nyu_sscs.merkle_proof._bytearray_from_hashes")
    def test_verify_consistency_success(
        self,
        mock_from_hashes,
        mock_validate,
        mock_layout,
        mock_border,
        mock_inner_right,
        mock_inner,
        mock_verify_match,
    ):
        hasher = MagicMock()
        tree_sizes = (4, 8)
        proof = ["aa", "bb"]
        root_hashes = ["abcd", "ef12"]

        mock_from_hashes.return_value = [b"a", b"b"]
        mock_layout.return_value = (b"seed", 1, 0, [b"x", b"y"])

        merkle_proof.verify_consistency(hasher, tree_sizes, proof, root_hashes)

        mock_from_hashes.assert_called_once_with(proof)
        mock_validate.assert_called_once_with(tree_sizes, [b"a", b"b"])
        mock_layout.assert_called_once_with(4, 8, bytes.fromhex("abcd"), [b"a", b"b"])
        mock_border.assert_any_call(hasher, b"h1_inner", [b"y"])
        mock_border.assert_any_call(hasher, b"h2", [b"y"])
        assert mock_verify_match.call_count == 2  # once per hash/root pair
