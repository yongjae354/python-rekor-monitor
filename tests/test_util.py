"""Unit tests for util.py. Generated by an AI assistant; review before use."""

import tempfile
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography import x509
from cryptography.x509.oid import NameOID
import datetime

from python_rekor_monitor import util


def create_self_signed_cert():
    """Generate a temporary ECDSA private key and self-signed certificate."""
    key = ec.generate_private_key(ec.SECP256R1())

    subject = issuer = x509.Name(
        [
            x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Test Org"),
            x509.NameAttribute(NameOID.COMMON_NAME, "test.local"),
        ]
    )

    cert = (
        x509.CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(key.public_key())
        .serial_number(x509.random_serial_number())
        .not_valid_before(datetime.datetime.now(datetime.UTC))
        .not_valid_after(datetime.datetime.now(datetime.UTC) + datetime.timedelta(days=10))
        .sign(private_key=key, algorithm=hashes.SHA256())
    )

    cert_pem = cert.public_bytes(serialization.Encoding.PEM)
    pubkey_pem = key.public_key().public_bytes(
        serialization.Encoding.PEM, serialization.PublicFormat.SubjectPublicKeyInfo
    )

    return key, cert_pem, pubkey_pem


def test_extract_public_key():
    _, cert_pem, pubkey_pem = create_self_signed_cert()
    extracted_key = util.extract_public_key(cert_pem)

    assert extracted_key == pubkey_pem


def test_verify_artifact_signature_valid(tmp_path):
    key, _, pubkey_pem = create_self_signed_cert()
    artifact_path = tmp_path / "artifact.txt"
    artifact_data = b"important data"
    artifact_path.write_bytes(artifact_data)

    signature = key.sign(artifact_data, ec.ECDSA(hashes.SHA256()))

    assert (
        util.verify_artifact_signature(signature, pubkey_pem, str(artifact_path))
        is True
    )


def test_verify_artifact_signature_invalid(tmp_path):
    key, _, pubkey_pem = create_self_signed_cert()
    artifact_path = tmp_path / "artifact.txt"
    artifact_path.write_bytes(b"tampered data")

    # Sign different data
    signature = key.sign(b"original data", ec.ECDSA(hashes.SHA256()))

    assert (
        util.verify_artifact_signature(signature, pubkey_pem, str(artifact_path))
        is False
    )
